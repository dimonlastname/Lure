{"version":3,"sources":["lure.chart.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","Lure","Plugin","Chart","Core","LureChart","Refresh","Buffer","SeriesBar","Init","Series","this","Block","Legend","AxisY","AxisX","Builder","ScaleY","Grid","MakeGrid","MakeAxisY","Options","Type","Svg","chart","__GetSvgCasual","__GetSvgPie","style","height","Height","lines","SelectAll","Content","LastRender","Width","forEach","item","dash","getTotalLength","strokeDasharray","strokeDashoffset","Target","arguments","undefined","_ref","_ref$Type","_ref$Title","Title","_ref$Labels","Labels","Rotation","Data","_ref$Grid","_ref$Series","_ref$Tooltip","Tooltip","Template","_ref$AxisY","Scale","Visible","SeriesOptions","ColorsDefault","TemplateDefault","Line","Pie","Count","Select","classList","add","position","isGraph","Abscissa","SeriesPoints","SeriesCount","Bar","Ring","ParametersAxisX","_Series","toLowerCase","Font","Family","Size","BarStack","BarGradient","PieStack","PieType","isNumeric","Padding","innerHTML","_Legend","querySelector","_AxisX","_AxisY","_ChartArea","_Grid","_Svg","v","ChartArea","bind","labels","AxisXParams","MarginLeft","Angle","MarginTop","a","borderTop","Make3Legend","Serie","Name","Color","_ScaleY","Scales","AxisYStyle","accum","index","Dict","indexOf","scale","caption","j","MakeAxisX","b","GetGrid","MakeGraph","serie","mm","MinMax","DataOrdinata","GetOrdinata","DataAbscissa","GetAbscissa","points","GetPoints","GetPath","CalcAxi6sX","c","CreateElementFromString","size","GetInlineSize","getComputedStyle","fontSize","w","paddingLeft","h","wFact","width","angle","parseFloat","cos","Math","round","sqrt","pow","Se","ep","Colors","isVisible","OwnAxis","Point","GetSeriePointOptions","MakeLegend","capitalize","push","len","GetTextWidth","lenmax","wCapti","Array","isArray","AxisYWidth","maxWidth","clientWidth","acos","PI","toFixed","lineHeight","GetScaleY","DataLength","__GetPathLine","line","n","xs","ys","dys","dxs","ds","ms","isFinite","d","dots","GetPathLineDot","Radius","__GetPathBar","deilmit","wd","margin","bricks","GradientId","bars","sectors","sum","anglestart","r","PieArc","Controller","BeforeShow","Prop","_Timer","_Timer2","Shower","clearTimeout","display","opacity","Hider","setTimeout","Show","options","data","Value","left","pos","top","clientHeight","backgroundColor","color","Methods","Do","e","tag","currentTarget","dataset","DoCircle","DoBar","DoPie","circle","parseInt","attributes","value","o","bar","setAttribute","offsetX","offsetY","Undo","UndoCircle","UndoBar","UndoPie","Hide","pie","AfterBuild","AddEventListenerGlobal","TestB","per","performance","now","Perf","call","get","p","Number","isNaN","series","ctx","min","max","isAutoScale","isAutoStep","sc","order","toString","step","s","stepX","map","scaleCoefficient","ordinata","X","Y","padding","type","GetPathLine","GetPathBar","isDots","x","y","console","log","do2ts","centerX","centerY","radius","angleInDegrees","angleInRadians","sin","startAngle","endAngle","start","PolarToCartesius","end","largeArcFlag","join","id","sizeX","sizeY","grid","_GenerateString","prefix","gen","random","replace","substring"],"mappings":"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","file":"lure.chart.min.js","sourcesContent":["Lure.Plugin.Chart = {\r\n    Core: '',\r\n    Chart: class LureChart{\r\n        constructor(\r\n            Target = null,      //where render chart\r\n            {\r\n                Type = 'Line',  //Line Bar Pie\r\n                Title = '',\r\n                Labels = {\r\n                    Rotation: 'auto',\r\n                    Data: []\r\n                },\r\n                Grid = {},\r\n                Series = [],\r\n                Tooltip = {\r\n                    Template: null,\r\n                },\r\n                AxisY = {\r\n                    Scale: ['auto', 'auto', 'auto'],\r\n                    Visible: true,\r\n                },\r\n                Height = 400,\r\n                SeriesOptions = {},\r\n            }={},\r\n        ){\r\n           // let pp = new Lure.Diagnostics.Perf(false);\r\n            /// <DEFAULTS>\r\n            //const Colors = ['red', 'green', 'blue'];\r\n            const ColorsDefault = ['red', 'green', 'cornflowerblue', 'purple', 'palevioletred', 'orange', 'tomato', 'darkblue'];\r\n            const TemplateDefault = {\r\n                Line: 'Name: {{Name}}<br>Value: {{Value}}',\r\n                Pie: 'Name: {{Name}}<br>Value: {{Value}}'\r\n            };\r\n            /// </DEFAULTS>\r\n            ///\r\n            Lure.Chart.Count++;\r\n            let chart = this;\r\n            this.Content = Lure.Select(Target);\r\n            this.Content.classList.add('mt-chart'); // mt\r\n            this.Content.style.position = 'relative';\r\n\r\n            this.isGraph = true;\r\n\r\n\r\n            let Prepared = [];\r\n            let Buffer = {\r\n                Legend: '',\r\n\r\n                AxisX: '',\r\n                AxisY: '',\r\n                Grid: '',\r\n                Svg: '',\r\n\r\n                Height: 0,\r\n                Width: 0,\r\n                Abscissa: null,\r\n                SeriesPoints: [],\r\n\r\n                SeriesCount:{\r\n                    Line: 0,\r\n                    Bar: 0,\r\n                    Pie: 0,\r\n                    Ring: 0,\r\n                },\r\n                SeriesBar: 0,\r\n\r\n                ParametersAxisX: null,\r\n            };\r\n            this._Series = Series;\r\n\r\n            this.Options = {\r\n                Type: Type? Type.toLowerCase(): 'line',\r\n                Title: Title? Title: '',\r\n                Legend: {\r\n                    Visible: true,\r\n                },\r\n                Labels: {\r\n                    Visible: (typeof Labels.Visible === 'undefined' || Labels.Visible),\r\n                    Rotation: Labels.Rotation? Labels.Rotation: 'auto',\r\n                    Data: Labels.Data? Labels.Data: [],\r\n                    Font: {\r\n                        Family: 'sans-serif',\r\n                        Size: '0.8rem',\r\n                    }\r\n                },\r\n                Grid: {\r\n                    Visible: (typeof Grid.Visible === 'undefined' || Grid.Visible),\r\n                },\r\n                Series: null,\r\n                SeriesOptions: {\r\n                    BarStack: false,\r\n                    BarGradient: true,\r\n\r\n                    PieStack: false,\r\n                    PieType: 'pie'\r\n                },\r\n                AxisY: {\r\n                    Font: {\r\n                        Family: 'sans-serif',\r\n                        Size: '0.8rem',\r\n                    },\r\n                    Scale: AxisY.Scale? ([Lure.isNumeric(AxisY.Scale[0])? AxisY.Scale[0]:'auto', Lure.isNumeric(AxisY.Scale[1])? AxisY.Scale[1]:'auto', Lure.isNumeric(AxisY.Scale[2])? AxisY.Scale[2]:'auto']):['auto', 'auto', 'auto'],\r\n                    Visible: (typeof AxisY.Visible === 'undefined' || AxisY.Visible),\r\n\r\n                },\r\n                Padding: 0,\r\n                Tooltip: {\r\n                    Template: null, //Tooltip.Template?Tooltip.Template : TemplateDefault.Line\r\n                }\r\n            };\r\n            this.Block = (function () {\r\n                this.Content.innerHTML = `<div class=\"mt-chart col\">\r\n                                        <div class=\"mt-chart-caption\">\r\n                                          <div class='mt-chart-title'>${Title}</div>\r\n                                          <div class=\"mt-chart-legend row\"></div>\r\n                                        </div>\r\n                                        <div class=\"mt-chart-kek row flex-100\">\r\n                                          <div class=\"mt-chart-y row\"></div>\r\n                                          <div class=\"col flex-100\">\r\n                                            <div class=\"mt-chart-area row flex-100\">\r\n                                              <svg class=\"mt-chart-svg\"></svg>\r\n                                              <div class=\"mt-chart-grid\" style=\" position: absolute;\"></div>\r\n                                            </div>\r\n                                            <div class=\"mt-chart-x row\"></div>\r\n                                           </div>\r\n                                        </div>\r\n                                      </div>`;\r\n                const _Legend     = this.Content.querySelector('.mt-chart-legend');\r\n                const _AxisX      = this.Content.querySelector('.mt-chart-x');\r\n                const _AxisY      = this.Content.querySelector('.mt-chart-y');\r\n                const _ChartArea  = this.Content.querySelector('.mt-chart-area');\r\n                const _Grid       = this.Content.querySelector('.mt-chart-grid');\r\n                const _Svg        = this.Content.querySelector('.mt-chart-svg');\r\n                return {\r\n                    get Legend(){\r\n                        return _Legend;\r\n                    },\r\n                    set Legend(v){\r\n                        _Legend.innerHTML = v;\r\n                    },\r\n                    get AxisX(){\r\n                        return _AxisX;\r\n                    },\r\n                    set AxisX(v){\r\n                        _AxisX.innerHTML = v;\r\n                    },\r\n                    get AxisY(){\r\n                        return _AxisY;\r\n                    },\r\n                    set AxisY(v){\r\n                        _AxisY.innerHTML = v;\r\n                    },\r\n                    get ChartArea(){\r\n                        return _ChartArea;\r\n                    },\r\n                    set ChartArea(v){\r\n                        _ChartArea.innerHTML = v;\r\n                    },\r\n                    get Grid(){\r\n                        return _Grid;\r\n                    },\r\n                    set Grid(v){\r\n                        _Grid.innerHTML = v;\r\n                    },\r\n                    get Svg(){\r\n                        return _Svg;\r\n                    },\r\n                    set Svg(v){\r\n                        _Svg.innerHTML = v;\r\n                    },\r\n                }\r\n            }.bind(this))();\r\n            /*********/\r\n            const Builder = {\r\n                Legend(){\r\n\r\n                },\r\n                AxisX: function(){\r\n                    if (!chart.Options.Labels.Visible)\r\n                    {\r\n                        this.Block.AxisX = '';\r\n                        return;\r\n                    }\r\n                    let labels = chart.Options.Labels.Data;\r\n                    //const style = `transform: rotate(${Buffer.AxisXParams.Angle}deg); margin-top: ${Buffer.AxisXParams.MarginTop}px; width: ${Buffer.AxisXParams.Width}px; margin-left: ${Buffer.AxisXParams.MarginLeft}px;`;\r\n                    const style = `transform: translate(${Buffer.AxisXParams.MarginLeft}px) rotate(${Buffer.AxisXParams.Angle}deg); margin-top: ${Buffer.AxisXParams.MarginTop}px ; width: ${Buffer.AxisXParams.Width}px;`;\r\n                    let a = '';\r\n                    for (let i = 0 ; i < labels.length; i++){\r\n                        a += `<div class=\"mt-chart-label mt-chart-label__x\" style=\"font-family: ${chart.Options.Labels.Font.Family}; font-size: ${chart.Options.Labels.Font.Size}\"><span style=\"${style}\">${labels[i]}</span></div>`\r\n                    }\r\n                    //console.log(`AxisX forecastHeight: ${Math.round(h/4+ (Math.sqrt(Math.pow(wFact, 2) - Math.pow(w, 2))))}`);\r\n                    Buffer.AxisX = a;\r\n                    this.Block.AxisX = a;\r\n                    this.Block.AxisX.style.borderTop = '1px #111 solid';\r\n                }.bind(this),\r\n                AxisY: function () {\r\n                    !this.Options.Labels.Visible\r\n                    return '';\r\n\r\n                }.bind(this),\r\n\r\n\r\n                Make3Legend(Serie, i){\r\n                    return `<div class=\"mt-chart-legend__item row\">\r\n                          <input class=\"mt-legend-checkbox\" type=\"checkbox\" checked=\"checked\" id=\"legcheck${Serie.Name}${i}\">\r\n                          <div class=\"mt-legend-icon\" style=\"background-color: ${Serie.Color}\"></div>\r\n                          <label class=\"mt-legend-label\" for=\"legcheck${Serie.Name}${i}\">${Serie.Name}</label>\r\n                        </div>`;\r\n                },\r\n                MakeAxisY(){\r\n                    /*if (!scale)\r\n                     return '';\r\n                     let caption = '';\r\n                     if (i>0)\r\n                     caption = `<div class=\"mt-chart-axis-caption\"><div style=\"transform: rotate(-90deg)\">${name}</div></div>`;\r\n                     let a = '';\r\n                     for (let j = 0; j< scale.length; j++){\r\n                     a += `<div class=\"mt-chart-label mt-chart-label__y\"><span>${scale[j]}</span></div>`;\r\n                     }\r\n                     return `<div class=\"mt-chart-axis__y row\" ${(i>0)? ('style=\"color: '+color+'; font-weight: bold;\"'):''} data-line=\"${i}\">${caption}<div class=\"mt-chart-labels col\">${a}</div></div>`;*/\r\n                    let i = 0;\r\n                    if (!chart.Options.AxisY.Visible){\r\n                        i = 1;\r\n                        if (chart._ScaleY.Scales.length < 2)\r\n                            return '';\r\n                    }\r\n                    let AxisYStyle = `font-family: ${chart.Options.Labels.Font.Family}; font-size: ${chart.Options.Labels.Font.Size};`;\r\n                    let accum = '';\r\n                    for (i; i <chart._ScaleY.Scales.length; i++){\r\n                        let index = chart._ScaleY.Dict.indexOf(i);//.filter(x=>x===i && x !==0)[0];\r\n                        let scale = chart._ScaleY.Scales[i];\r\n                        let caption = '';\r\n                        //let a = '';\r\n                        if (i>0)\r\n                            caption = `<div class=\"mt-chart-axis-caption\"><div style=\"transform: rotate(-90deg)\">${chart.Options.Series[index].Title}</div></div>`;\r\n                        let a = '';\r\n                        for (let j = 0; j< scale.length; j++){\r\n                            a += `<div class=\"mt-chart-label mt-chart-label__y\"><span>${scale[j]}</span></div>`;\r\n                        }\r\n                        if (i>0)\r\n                            AxisYStyle += ` color: ${chart.Options.Series[index].Color}; font-weight: bold;`;\r\n                        accum += `<div class=\"mt-chart-axis__y row\" style=\"${AxisYStyle}\" data-line=\"${i}\">${caption}<div class=\"mt-chart-labels col\">${a}</div></div>`;\r\n\r\n                    }\r\n                    return accum;\r\n                },\r\n                MakeAxisX(){\r\n                    if (!chart.Options.Labels.Visible)\r\n                        return '';\r\n                    let labels = chart.Options.Labels.Data;\r\n\r\n                    //const style = `transform: rotate(${Buffer.AxisXParams.Angle}deg); margin-top: ${Buffer.AxisXParams.MarginTop}px; width: ${Buffer.AxisXParams.Width}px; margin-left: ${Buffer.AxisXParams.MarginLeft}px;`;\r\n                    const style = `transform: translate(${Buffer.AxisXParams.MarginLeft}px) rotate(${Buffer.AxisXParams.Angle}deg); margin-top: ${Buffer.AxisXParams.MarginTop}px ; width: ${Buffer.AxisXParams.Width}px;`;\r\n                    let a = '';\r\n                    for (let i = 0 ; i < labels.length; i++){\r\n                        a += `<div class=\"mt-chart-label mt-chart-label__x\" style=\"font-family: ${chart.Options.Labels.Font.Family}; font-size: ${chart.Options.Labels.Font.Size}\"><span style=\"${style}\">${labels[i]}</span></div>`\r\n                    }\r\n                    //console.log(`AxisX forecastHeight: ${Math.round(h/4+ (Math.sqrt(Math.pow(wFact, 2) - Math.pow(w, 2))))}`);\r\n                    return a;\r\n                },\r\n                MakeGrid(a,b){\r\n                    if (!chart.Options.Grid.Visible)\r\n                        return '';\r\n                    return Lure.Chart.GetGrid(chart.Options.Labels.Data.length, chart._ScaleY.Scales[0].length-1, chart.Options.Padding);\r\n                },\r\n                MakeGraph(serie, i){\r\n                    let index = chart._ScaleY.Dict[i];\r\n                    let scale = chart._ScaleY.Scales[index];\r\n                    let mm = chart._ScaleY.MinMax[index];\r\n                    let DataOrdinata = Lure.Chart.GetOrdinata(serie.Data, scale, mm, chart.Height);\r\n                    let DataAbscissa = Lure.Chart.GetAbscissa(chart.Options.Labels.Data, chart.Width);\r\n                    let points = Lure.Chart.GetPoints(DataAbscissa, DataOrdinata);\r\n                    return Lure.Chart.GetPath(points, chart.Options.Series[i].Type, i, chart.Options.Series[i].Color, chart.Options.Series[i].Width);\r\n                },\r\n                CalcAxi6sX(){\r\n                    let c = Lure.CreateElementFromString(`<div class=\"mt-chart-label mt-chart-label__x\"><span>${chart.Options.Labels.Data[0]}</span></div>`);\r\n                    //let pp = performance.now();\r\n                    let size = Lure.GetInlineSize(c, getComputedStyle(Lure.Select('span')).fontSize);\r\n\r\n                    let w = chart.Width/chart.Options.Labels.Data.length;\r\n                    chart.Options.Padding = w/2;\r\n                    chart.Block.AxisX.style.paddingLeft = w/2+'px';\r\n                    let h = size.height;\r\n                    let wFact = size.width;\r\n                    let angle;\r\n\r\n                    if (chart.Options.Labels.Rotation !== 'auto'){\r\n                        angle = parseFloat(chart.Options.Labels.Rotation);\r\n                    }\r\n                    else{\r\n                        let cos = (w-h)/(wFact+h);\r\n                        if (cos < 0.1)\r\n                            cos = 0;\r\n                        if (cos > 1)\r\n                            cos = 1;\r\n                        angle = (-90*(1-cos));\r\n                    }\r\n                    //Lure.Perf(pp, '--calcx--');\r\n                    return {\r\n                        Height: Math.round(h/4+ (Math.sqrt(Math.pow(wFact, 2) - Math.pow(w, 2)))),\r\n                        Width: wFact,\r\n                        MarginTop:  (wFact>w)? ((Math.sqrt(Math.pow(wFact, 2) - Math.pow(w, 2))) - h) : 0,\r\n                        MarginLeft: (wFact>w)? (-w/2):(-wFact/2),\r\n                        Angle: angle,\r\n                    }\r\n\r\n                }\r\n            };\r\n\r\n            const Init = {\r\n                Tooltip: function () {\r\n                    if (Tooltip.Template)\r\n                    {\r\n                        this.Options.Tooltip.Template = Tooltip.Template;\r\n                        return;\r\n                    }\r\n                    if (this.Options.Type === 'line' || this.Options.Type === 'bar'){\r\n                        this.Options.Tooltip.Template = TemplateDefault.Line;\r\n                        return;\r\n                    }\r\n                    if (this.Options.Type === 'pie' || this.Options.Type === 'ring'){\r\n                        this.Options.Tooltip.Template = TemplateDefault.Pie;\r\n                        return;\r\n                    }\r\n\r\n                    //Tooltip.Template?Tooltip.Template : TemplateDefault.Line\r\n                }.bind(this),\r\n                Series: function(){\r\n                    let Se = [];\r\n                    if (this.Options.Series !== null){\r\n\r\n                        return;\r\n                    }\r\n                    for (let i = 0; i < this._Series.length; i++){\r\n                        let ep = {};\r\n                        ep.Name    = this._Series[i].Name ? this._Series[i].Name                : 'Unnamed';\r\n                        ep.Title   = this._Series[i].Title? this._Series[i].Title               : ep.Name;\r\n                        ep.Color   = this._Series[i].Color? this._Series[i].Color: ColorsDefault[i]?ColorsDefault[i]:'#000';\r\n                        ep.Width   = this._Series[i].Width? this._Series[i].Width               : 2;\r\n\r\n                        ep.Data    = this._Series[i].Data;\r\n\r\n                        ep.Type    = this._Series[i].Type ? this._Series[i].Type.toLowerCase()  : (Type?Type.toLowerCase():'line');\r\n                        //debugger;\r\n                        if (ep.Type === 'pie' || ep.Type === 'ring'){\r\n                            ep.Colors = this._Series[i].Colors? this._Series[i].Colors: ColorsDefault;\r\n                            ep.Width   = this._Series[i].Width? this._Series[i].Width               : 30;\r\n                            ep.Labels  = this._Series[i].Labels? this._Series[i].Labels: (this.Options.Labels.Data?this.Options.Labels.Data: false);\r\n\r\n                        }\r\n\r\n\r\n                        ep.Line    = i;\r\n                        ep.isVisible = (typeof this._Series[i].Visible === 'undefined' || this._Series[i].Visible); //true by default\r\n                        ep.OwnAxis = this._Series[i].OwnAxis;\r\n                        //ep.OwnAxis = Lure.Chart.CheckOwnAxis(ep);\r\n\r\n\r\n                        ep.Point   = this._Series[i].Point;\r\n                        ep.Point   = Lure.Chart.GetSeriePointOptions(ep);\r\n\r\n                        Buffer.Legend += Lure.Chart.MakeLegend(ep, i);\r\n                        Buffer.SeriesCount[ep.Type.capitalize()]++;\r\n                        Se.push(ep);\r\n                    }\r\n                    this.Options.Series = Se;\r\n                }.bind(this),\r\n                AxisY: function () {\r\n                    if (this.Width === LastRender.Width)\r\n                        return;\r\n                    let count = this.Options.AxisY.Visible? 1:0;\r\n                    let len = 0;\r\n                    let width = 0;\r\n                    for (let i = 0; i < this.Options.Series.length; i++){\r\n                        //check special Scales\r\n                        if (this.Options.Series[i].isVisible && this.Options.Series[i].OwnAxis){\r\n                            let len = 0;\r\n                            for (let j = 0; j < this.Options.Series[i].Data.length; j++){\r\n                                let w = Lure.GetTextWidth(this.Options.Series[i].Data[j], this.Options.AxisY.Font.Family, this.Options.AxisY.Font.Size);\r\n                                if (w > len)\r\n                                    len = this.Options.Series[i].Data[j];\r\n                            }\r\n                            let lenmax = Lure.GetTextWidth(this.Options.Series[i].OwnAxis[1], this.Options.AxisY.Font.Family, this.Options.AxisY.Font.Size);\r\n                            if (lenmax > len)\r\n                                len = lenmax;\r\n                            //debugger;\r\n                            //width += Lure.GetTextWidth('i'.repeat(len), this.Options.AxisY.Font.Family, this.Options.AxisY.Font.Size);\r\n                            width += len + 8;  //8px = (7px) :before.width  + (1px) border\r\n                            let wCapti = Lure.GetTextWidth(this.Options.Series[i].Title, this.Options.AxisY.Font.Family, this.Options.AxisY.Font.Size);\r\n                            width += wCapti > 30 ? 30: wCapti;\r\n                        }\r\n                        //check default scale\r\n                        else if (this.Options.Series[i].isVisible && !Array.isArray(this.Options.Series[i].OwnAxis)){\r\n                            for (let j = 0; j < this.Options.Series[i].Data.length; j++){\r\n                                let w = Lure.GetTextWidth(this.Options.Series[i].Data[j], this.Options.AxisY.Font.Family, this.Options.AxisY.Font.Size);\r\n                                if (w > len)\r\n                                    len = this.Options.Series[i].Data[j];\r\n                            }\r\n                        }\r\n                    }\r\n                    width += len + 10 +7;\r\n                    Buffer.AxisYWidth = width;\r\n                   // console.log('->Init.AxisY:',width);\r\n                }.bind(this),\r\n                AxisX: function () {\r\n                    if (this.Width === LastRender.Width)\r\n                        return;\r\n                    if (!this.Options.Labels.Visible){\r\n                        Buffer.AxisXParams = {\r\n                            Height: 0,\r\n                            Width: 0,\r\n                            MarginTop:  0,\r\n                            MarginLeft: 0,\r\n                            Angle: 0,\r\n                        };\r\n                        return;\r\n                    }\r\n\r\n                    let maxWidth = 0;\r\n                    for (let i = 0; i < this.Options.Labels.Data.length; i++){\r\n                        let w = Lure.GetTextWidth(this.Options.Labels.Data[i], this.Options.AxisY.Font.Family, this.Options.AxisY.Font.Size);\r\n                        if (w > maxWidth)\r\n                            maxWidth = w;\r\n                    }\r\n                    let w = (this.Content.clientWidth - Buffer.AxisYWidth) / this.Options.Labels.Data.length;\r\n                    w = (this.Content.clientWidth - Buffer.AxisYWidth - w/2) / this.Options.Labels.Data.length;\r\n                    //debugger;\r\n                    this.Options.Padding = w/2;\r\n                    this.Block.AxisX.style.paddingLeft = w/2+'px';\r\n                    let h = 0; //TODO hardcode fix\r\n                    let wFact = maxWidth;\r\n                    let angle;\r\n\r\n                    if (this.Options.Labels.Rotation !== 'auto'){\r\n                        angle = parseFloat(this.Options.Labels.Rotation);\r\n                    }\r\n                    else{\r\n                        let cos = (w)/(wFact);\r\n                        if (cos < 0.15)\r\n                            cos = 0;\r\n                        if (cos > 1)\r\n                            cos = 1;\r\n                        //angle = (-90*(1-cos));\r\n                        //console.log('w',this.Width, w, wFact,cos);\r\n                        angle = -(Math.acos(cos)*180/Math.PI).toFixed(2);\r\n                       /* if (angle >0 )\r\n                            angle = -angle;*/\r\n                        //console.log('angleold', (-90*(1-cos)));\r\n                        //console.log('anglenew', h, parseFloat(getComputedStyle(this.Block.AxisX).lineHeight));\r\n                    }\r\n                    //Lure.Perf(pp, '--calcx--');\r\n                    Buffer.AxisXParams = {\r\n                        Height: Math.round((Math.sqrt(Math.pow(wFact, 2) - Math.pow(w, 2)))) + parseFloat(getComputedStyle(this.Block.AxisX).lineHeight),\r\n                        Width: wFact,\r\n                        MarginTop:  (wFact>w)? ((Math.sqrt(Math.pow(wFact, 2) - Math.pow(w, 2))) - h) : 0,\r\n                        MarginLeft: (wFact>w)? (-w/2):(-(wFact)/2),\r\n                        Angle: angle,\r\n                    }\r\n\r\n\r\n\r\n                }.bind(this),\r\n                ScaleY: function () {\r\n                    this._ScaleY = Lure.Chart.GetScaleY(this.Options.Series, (this.Height-Buffer.AxisXParams.Height), this);\r\n                    return;\r\n                    if (ctx.Type === 'pie'){\r\n                        return [];\r\n                    }\r\n                    let min = series[0].Data[0];\r\n                    let max = series[0].Data[0];\r\n                    let isAutoScale = true;\r\n                    let isAutoStep = true;\r\n                    if (ctx.Options.AxisY.Scale[0] !== 'auto' && ctx.Options.AxisY.Scale[1] !== 'auto')\r\n                    {\r\n                        isAutoScale = false;\r\n                        min = ctx.Options.AxisY.Scale[0];\r\n                        max = ctx.Options.AxisY.Scale[1];\r\n                    }\r\n                    if (ctx.Options.AxisY.Scale[2] !== 'auto')\r\n                        isAutoStep = false;\r\n                    let mm = [ [series[0].Data[0],series[0].Data[0]] ];\r\n                    let index = 0;\r\n                    let scales = [];\r\n\r\n                    let sc = {\r\n                        Scales: [],\r\n                        Dict: [],\r\n                        MinMax: null\r\n                    };\r\n                    for (let i = 0; i < series.length; i++){\r\n                        sc.Dict[i] = 0;\r\n                        if (series[i].OwnAxis){\r\n                            index++;\r\n                            if (typeof series[i].OwnAxis[0] !== 'undefined')\r\n                                mm.push(series[i].OwnAxis);\r\n                            else\r\n                                mm.push([series[i].Data[0],series[i].Data[0]]);\r\n                            sc.Dict[i] = index;\r\n                        }\r\n                        for (let j = 0; j < series[i].Data.length; j++){\r\n                            if (isAutoScale){\r\n                                if (series[i].Data[j] < min)\r\n                                    min = series[i].Data[j];\r\n                                if (series[i].Data[j] > max)\r\n                                    max = series[i].Data[j];\r\n                            }\r\n                            if (series[i].OwnAxis && typeof series[i].OwnAxis[0] === 'undefined'){\r\n                                if (series[i].Data[j] < mm[index][0])\r\n                                    mm[index][0] = series[i].Data[j];\r\n                                if (series[i].Data[j] > mm[index][1])\r\n                                    mm[index][1] = series[i].Data[j];\r\n                            }\r\n                        }\r\n                    }\r\n                    mm[0] = [min, max];\r\n                    sc.MinMax = mm;\r\n                    for (let i = 0; i < mm.length; i++){\r\n                        let order = mm[i][1].toString().length;\r\n                        let step;\r\n                        if (i===0 && !isAutoStep){\r\n                            step = ctx.Options.AxisY.Scale[2];\r\n                        }\r\n                        else{\r\n                            step = mm[i][2]? mm[i][2] : ( (mm[i][1]-mm[i][0] )*40 /height / (Math.pow(10, order-1))/5 ).toFixed(1) * Math.pow(10, order-1)*5;\r\n                        }\r\n                        let s = mm[i][0];\r\n                        let scale = [];\r\n                        if (order < 3 || true){\r\n                            //debugger;\r\n                            while (s <= mm[i][1] + ctx.Options.Series[i].Width/2){\r\n                                scale.push(s);\r\n                                s += step;\r\n                            }\r\n                            scale.push(s);\r\n                            sc.Scales.push(scale);\r\n                        }\r\n                    }\r\n                    return sc;\r\n                }.bind(this)\r\n            };\r\n            /**\r\n             *\r\n             * @returns {string}\r\n             * @constructor\r\n             */\r\n\r\n\r\n            let LastRender = {\r\n                Width: 0,\r\n                Height: 0,\r\n                DataLength: 0,\r\n\r\n            };\r\n\r\n\r\n            this.__GetPathLine = function (serie, line) {\r\n                if (!Buffer.Abscissa || Buffer.Width !== this.Width)\r\n                    Buffer.Abscissa = Lure.Chart.GetAbscissa(chart.Options.Labels.Data, this.Width);\r\n                let index = this._ScaleY.Dict[line];\r\n                let scale = this._ScaleY.Scales[index];\r\n                let mm = chart._ScaleY.MinMax[index];\r\n                //debugger;\r\n                let DataOrdinata = Lure.Chart.GetOrdinata(serie.Data, scale, mm, chart.Height);\r\n                let points = Lure.Chart.GetPoints(Buffer.Abscissa, DataOrdinata, this.Options.Padding);\r\n                Buffer.SeriesPoints[line] = points;\r\n\r\n                const n = points.length;\r\n\r\n                let xs = [];        //x\r\n                let ys = [];        //y\r\n                let dys = [];       //dx\r\n                let dxs = [];       //dy\r\n                let ds = [];        //derivative\r\n                let ms = [];        //desired slope (m) at each point using Fritsch-Carlson method\r\n                for(let i = 0; i < n; i++) {\r\n                    xs[i] = points[i][0];\r\n                    ys[i] = points[i][1];\r\n                }\r\n                // Calculate deltas and derivative\r\n                for(let i = 0; i < n - 1; i++) {\r\n                    dys[i] = ys[i + 1] - ys[i];\r\n                    dxs[i] = xs[i + 1] - xs[i];\r\n                    ds[i] = dys[i] / dxs[i];\r\n                }\r\n                // Determine desired slope (m) at each point using Fritsch-Carlson method\r\n                // See: http://math.stackexchange.com/questions/45218/implementation-of-monotone-cubic-interpolation\r\n                ms[0] = ds[0];\r\n                ms[n - 1] = ds[n - 2];\r\n                for(let i = 1; i < n - 1; i++) {\r\n                    if(ds[i] === 0 || ds[i - 1] === 0 || (ds[i - 1] > 0) !== (ds[i] > 0)) {\r\n                        ms[i] = 0;\r\n                    } else {\r\n                        ms[i] = 3 * (dxs[i - 1] + dxs[i]) / (\r\n                            (2 * dxs[i] + dxs[i - 1]) / ds[i - 1] +\r\n                            (dxs[i] + 2 * dxs[i - 1]) / ds[i]);\r\n                        if(!isFinite(ms[i])) {\r\n                            ms[i] = 0;\r\n                        }\r\n                    }\r\n                }\r\n                let d = `M ${xs[0]},${ys[0]}`;\r\n                let dots = '<g class=\"mt-chart-dots\">';\r\n                for(let i = 0; i < n - 1; i++) {\r\n                    d += ` C ${xs[i] + dxs[i] / 3},${ys[i] + ms[i] * dxs[i] / 3} ${xs[i + 1] - dxs[i] / 3},${ys[i + 1] - ms[i + 1] * dxs[i] / 3} ${xs[i + 1]},${ys[i + 1]}`;\r\n                    if (serie.Point.Visible)\r\n                        dots += Lure.Chart.GetPathLineDot(xs[i] , ys[i], line, i, serie.Color, serie.Point.Radius );\r\n                }\r\n                if (serie.Point.Visible)\r\n                    dots += Lure.Chart.GetPathLineDot(xs[n-1] , ys[n-1], line, n-1, serie.Color, serie.Point.Radius );\r\n                dots += '</g>';\r\n                return `<g class=\"mt-chart-serie\" data-type=\"Line\"><path data-line=\"${line}\" d=\"${d}\" fill=\"none\" stroke=\"${serie.Color}\" stroke-width=\"${serie.Width}\"></path> ${dots}</g>`;\r\n\r\n            }.bind(this);\r\n            this.__GetPathBar = function (serie, line) {\r\n                if (!Buffer.Abscissa || Buffer.Width !== this.Width)\r\n                    Buffer.Abscissa = Lure.Chart.GetAbscissa(chart.Options.Labels.Data, this.Width);\r\n                let index = this._ScaleY.Dict[line];\r\n                let scale = this._ScaleY.Scales[index];\r\n                let mm = chart._ScaleY.MinMax[index];\r\n                //debugger;\r\n                let DataOrdinata = Lure.Chart.GetOrdinata(serie.Data, scale, mm, chart.Height);\r\n                let points = Lure.Chart.GetPoints(Buffer.Abscissa, DataOrdinata, this.Options.Padding);\r\n                Buffer.SeriesPoints[line] = points;\r\n                let height = this.Height;\r\n\r\n                let deilmit = 1;\r\n                if (!this.Options.SeriesOptions.BarStack)\r\n                    deilmit = Buffer.SeriesCount.Bar * 0.8;\r\n                let wd = this.Width/this.Options.Labels.Data.length/2 / deilmit;        //serie.Width;\r\n                let margin = ((wd*1.2) * (Buffer.SeriesBar)) - (  (wd*1.2) *Buffer.SeriesCount.Bar /2 - (wd*1.2)/2) ;\r\n\r\n               // debugger;\r\n\r\n                let bricks = '<g class=\"mt-chart-serie\" data-type=\"Bar\">';\r\n                let GradientId = '';\r\n                if (this.Options.SeriesOptions.BarGradient){\r\n                    GradientId = `lc-gradient-${Lure.Chart.Count}`;\r\n                    bricks += `<linearGradient id=\"${GradientId}\"  x1=\"0\" y1=\"0%\"><stop offset=\"0%\" stop-color=\"rgba(0,0,0,0.2)\"/><stop offset=\"33%\" stop-color=\"rgba(255,255,255,0.2)\"/><stop offset=\"100%\" stop-color=\"rgba(0,0,0,0.3)\"/></linearGradient>`;\r\n                }\r\n                // let d = `M ${points[0][0]}  ${points[0][1]}`;\r\n                let dots = '';\r\n                for (let i = 0; i < points.length; i++){\r\n                    let d =`M ${margin+points[i][0]-wd/2} ${height} L ${(margin+points[i][0]+wd/2)} ${height} ${(margin+points[i][0]+wd/2)} ${points[i][1]} ${margin+points[i][0]-wd/2} ${points[i][1]}Z`;\r\n                    // debugger;\r\n                    bricks += `<g class=\"lc-bar-elem\"><path class=\"lc-bar-elem\" data-line=\"${line}\" data-item=\"${i}\" d=\"${d}\" fill=\"${serie.Color}\" stroke=\"#000\" stroke-width=\"0\"></path>`;\r\n                    if (this.Options.SeriesOptions.BarGradient)\r\n                        bricks += `<path class=\"lc-bar-elem-gradient\"  data-line=\"${line}\" data-item=\"${i}\" d=\"${d}\" fill=\"url(#${GradientId})\" ></path>`;\r\n                    bricks += `<path class=\"mt-chart-tooltipable\" data-type=\"bar\" data-line=\"${line}\" data-item=\"${i}\" d=\"${d}\" fill=\"#fff\" fill-opacity=\"0\" stroke=\"#fff\" stroke-width=\"0\"></path>`;\r\n                    bricks +='</g>';\r\n                    //dots += Lure.Chart.GetPathLineDot(points[i][0] , points[i][1], line, i, serie.Color, serie.Point.Radius );\r\n                }\r\n                bricks += dots+'</g>';\r\n                Buffer.SeriesBar++;\r\n                return bricks;\r\n            }.bind(this);\r\n            this.__GetSvgCasual = function () {\r\n                let lines = '';\r\n                let bars  = '';\r\n                for (let i = 0; i < this.Options.Series.length; i++){\r\n                    if (!this.Options.Series[i].isVisible)\r\n                        continue;\r\n                    switch (this.Options.Series[i].Type){\r\n                        case 'line':\r\n                            lines += this.__GetPathLine(this.Options.Series[i], i);\r\n                            break;\r\n                        case 'bar':\r\n                            bars += this.__GetPathBar(this.Options.Series[i], i);\r\n                            break;\r\n                    }\r\n                }\r\n                return bars+lines;\r\n            }.bind(this);\r\n            this.__GetSvgPie = function () {\r\n                let sectors = '';\r\n                let d = this.Height< this.Width? this.Height*0.9:this.Width*0.9;\r\n                //r= r/4;\r\n                //let wd = 2*r;\r\n                for (let i = 0; i < this.Options.Series.length; i++){\r\n                    let sum = 0;\r\n                    let anglestart = -45;\r\n                    let r = d/4 * (this.Options.Series.length-i)/(Buffer.SeriesCount.Pie+Buffer.SeriesCount.Ring);\r\n                    let wd = 2*r;\r\n                    if (this.Options.Series[i].Type === 'ring'){\r\n                        wd = this.Options.Series[i].Width;\r\n                        r = r*2 - wd/2;\r\n\r\n                    }\r\n                    for (let j = 0; j < this.Options.Series[i].Data.length; j++){\r\n                        sum += this.Options.Series[i].Data[j];\r\n                    }\r\n                    for (let j = 0; j < this.Options.Series[i].Data.length; j++){\r\n                        let angle = this.Options.Series[i].Data[j]/sum * 360;\r\n                        //debugger;\r\n                        sectors += `<g>`;\r\n                        sectors += `<path d=\"${Lure.Chart.PieArc(this.Width/2, this.Height/2, r, anglestart, anglestart+angle)}\" fill=\"none\" stroke=\"${this.Options.Series[i].Colors[j]}\" stroke-width=\"${wd}\" stroke-opacity=\"1\"></path>`;\r\n                        sectors += `<path class=\"mt-chart-tooltipable\" data-type=\"pie\" data-line=\"${i}\" data-item=\"${j}\" d=\"${Lure.Chart.PieArc(this.Width/2, this.Height/2, r, anglestart, anglestart+angle)}\" fill=\"none\" stroke=\"#fff\" stroke-width=\"${wd}\" stroke-opacity=\"0\"></path>`;\r\n                        sectors += `</g>`;\r\n                        anglestart += angle;\r\n                        //debugger;\r\n                    }\r\n                }\r\n                //debugger;\r\n                return sectors;\r\n            }.bind(this);\r\n\r\n\r\n\r\n\r\n\r\n            function Refresh(){\r\n                Buffer.SeriesBar = 0;\r\n\r\n                //-1. check Tooltip Temptale\r\n                //Init.Tooltip();\r\n               // //pp.Perf('Check-Tooltip');\r\n                //0. build legend\r\n\r\n                Init.Series();\r\n                //pp.Perf('Init-Series');\r\n\r\n                this.Block.Legend = Buffer.Legend;\r\n                //pp.Perf('Render-Legend');\r\n\r\n                //1. Init Y width\r\n\r\n                Init.AxisY();\r\n                //pp.Perf('Init-AxisY');\r\n                //2. Init X height, and build AxisX cuz we have Y width.\r\n                //Buffer.ParametersAxisX = Builder.CalcAxisX();\r\n                Init.AxisX();\r\n                Builder.AxisX();\r\n                //pp.Perf('Init-AxisX');\r\n                //3. Init scales Y axis\r\n\r\n                Init.ScaleY();\r\n                //this._ScaleY = Lure.Chart.GetScaleY(this.Options.Series, (this.Height-Buffer.ParametersAxisX.Height), this);\r\n                //this._ScaleY = Lure.Chart.GetScaleY(this.Options.Series, (this.Height-Buffer.AxisXParams.Height), this);\r\n                //pp.Perf('Init-AxisYScales');\r\n\r\n\r\n                //this.Block.AxisX = Builder.MakeAxisX();\r\n                //this.Block.AxisX.style.height = Buffer.AxisXParams.Height+'px';\r\n\r\n\r\n                this.Block.Grid  = Builder.MakeGrid();\r\n                //pp.Perf('Render-Grid');\r\n\r\n                this.Block.AxisY = Builder.MakeAxisY();\r\n                //pp.Perf('Render-AxisY');\r\n                if (this.Options.Type === 'line' || this.Options.Type === 'bar')\r\n                    this.Block.Svg   = chart.__GetSvgCasual();\r\n                if (this.Options.Type === 'pie' || this.Options.Type === 'ring')\r\n                    this.Block.Svg   = chart.__GetSvgPie();\r\n                this.Block.AxisY.style.height = this.Height+'px';\r\n                //pp.Perf('Render-Svg');\r\n\r\n                let lines = Lure.SelectAll('.mt-chart-serie[data-type=\"Line\"] path', this.Content);\r\n                LastRender.Height = this.Height;\r\n                LastRender.Width = this.Width;\r\n                lines.forEach(function (item) {\r\n                    const dash = item.getTotalLength();\r\n                    item.style.strokeDasharray = dash;\r\n                    item.style.strokeDashoffset = dash;\r\n                });\r\n                //pp.Perf('Animations-add');\r\n                //pp.Elapsed('-elapsed-');\r\n            }\r\n\r\n\r\n            /********************************************************************************/\r\n            /*******/\r\n            /*<tooltips>*/\r\n            Init.Tooltip();\r\n            this.Tooltip = new Lure.Content({\r\n                Name: 'Tooltipchek',\r\n                Target: this.Block.ChartArea,\r\n                Content: `<div class=\"mt-chart-tooltip\">\r\n                        <div class=\"val\">${this.Options.Tooltip.Template}</div>\r\n                      </div>`,\r\n                Visible: false,\r\n                Controller: {\r\n                    Data: {},\r\n                },\r\n                BeforeShow: function (a,b) {\r\n\r\n                },\r\n                Prop: function () {\r\n                    this._Timer = null;\r\n                    this._Timer2 = null;\r\n                },\r\n                Shower: function () {\r\n                    clearTimeout(this._Timer);\r\n                    clearTimeout(this._Timer2);\r\n                    this.Content.style.display = '';\r\n                    this.Content.style.opacity = '1';\r\n                },\r\n                Hider: function () {\r\n                    clearTimeout(this._Timer);\r\n                    this._Timer = setTimeout(\r\n                        function () {\r\n                            this.Content.style.opacity = '0';\r\n                            this._Timer2 = setTimeout(function () {\r\n                                this.Content.style.display = 'none';\r\n                            }.bind(this), 200)\r\n\r\n                        }.bind(this), 800);\r\n                },\r\n                Show: function (options) {\r\n                    clearTimeout(this._Timer);\r\n                    this.Data.Name = options.data[0];\r\n                    this.Data.Value = options.data[1];\r\n                    this.Refresh();\r\n                    this.Content.style.left = (options.pos[0] + 7)+\"px\";\r\n                    this.Content.style.top = (options.pos[1] - this.Content.clientHeight - 7)+\"px\";\r\n                    this.Content.style.backgroundColor = options.color;\r\n                    //this._Timer = setTimeout(this.Hide, 2000);\r\n                },\r\n                Methods: function () {\r\n                    this.Do = function (e) {\r\n                        let tag = e.currentTarget.dataset['type'];\r\n                        switch (tag){\r\n                            case 'line':\r\n                                this.DoCircle(e);\r\n                                break;\r\n                            case 'bar':\r\n                                this.DoBar(e);\r\n                                break;\r\n                            case 'pie':\r\n                                this.DoPie(e);\r\n                                break;\r\n\r\n                        }\r\n\r\n\r\n                    }.bind(this);\r\n                    this.DoCircle = function (e) {\r\n                        let circle = e.currentTarget;\r\n                        let i = parseInt(circle.dataset['line']);\r\n                        let j = parseInt(circle.dataset['item']);\r\n                        let color = circle.attributes['stroke'].value;\r\n                        //console.log(` parseInt(circle.attributes['r'].value`,  parseInt(circle.attributes['r'].value) );\r\n                        let width = parseInt(circle.attributes['stroke-width'].value);\r\n                        circle.attributes['fill'].value = color;\r\n                        circle.attributes['r'].value = parseInt(circle.attributes['r'].value) + width;\r\n                        circle.attributes['stroke'].value = \"#fff\";\r\n\r\n\r\n                        //console.log('', i, j, Buffer.SeriesPoints[i][j], [e.offsetX, e.offsetY]);\r\n                        let o = {\r\n                            data: [Series[i].Name, Series[i].Data[j]],\r\n                            color: color,\r\n                            pos: Buffer.SeriesPoints[i][j]  //[e.offsetX, e.offsetY]\r\n                        };\r\n                        this.Show(o);\r\n                    }.bind(this);\r\n                    this.DoBar = function (e) {\r\n                        let bar = e.currentTarget;\r\n                        bar.setAttribute('fill-opacity', 0.2);\r\n                        let i = parseInt(bar.dataset['line']);\r\n                        let j = parseInt(bar.dataset['item']);\r\n                        // bar.attributes['stroke-width'].value = 2;\r\n                        //console.log('', i, j, Buffer.SeriesPoints[i][j], [e.offsetX, e.offsetY]);\r\n                        let o = {\r\n                            data: [chart.Options.Series[i].Name, chart.Options.Series[i].Data[j]],\r\n                            color: chart.Options.Series[i].Color,\r\n                            pos: Buffer.SeriesPoints[i][j]  //[e.offsetX, e.offsetY]\r\n                        };\r\n                        this.Show(o);\r\n                    }.bind(this);\r\n                    this.DoPie = function (e) {\r\n                        let bar = e.currentTarget;\r\n                        bar.setAttribute('stroke-opacity', 0.2);\r\n                        let i = parseInt(bar.dataset['line']);\r\n                        let j = parseInt(bar.dataset['item']);\r\n                        // bar.attributes['stroke-width'].value = 2;\r\n                        //console.log('', i, j, Buffer.SeriesPoints[i][j], [e.offsetX, e.offsetY]);\r\n                        let o = {\r\n                            data: [chart.Options.Series[i].Labels? chart.Options.Series[i].Labels[j]: chart.Options.Series[i].Name, chart.Options.Series[i].Data[j]],\r\n                            color: chart.Options.Series[i].Colors[j],\r\n                            pos: [e.offsetX, e.offsetY]\r\n                        };\r\n                        this.Show(o);\r\n                    }.bind(this);\r\n\r\n                    this.Undo = function (e) {\r\n                        let tag = e.currentTarget.dataset['type'];\r\n                        switch (tag){\r\n                            case 'line':\r\n                                this.UndoCircle(e);\r\n                                break;\r\n                            case 'bar':\r\n                                this.UndoBar(e);\r\n                                break;\r\n                            case 'pie':\r\n                                this.UndoPie(e);\r\n                                break;\r\n                        }\r\n                    };\r\n                    this.UndoCircle = function (e) {\r\n                        let circle = e.currentTarget;\r\n                        let width = parseInt(circle.attributes['stroke-width'].value);\r\n                        circle.attributes['stroke'].value = circle.attributes['fill'].value;\r\n                        circle.attributes['fill'].value = \"#fff\";\r\n                        circle.attributes['r'].value -= width;\r\n                        this.Hide();\r\n                    };\r\n                    this.UndoBar = function (e) {\r\n                        let bar = e.currentTarget;\r\n                        bar.setAttribute('fill-opacity', 0);\r\n                        this.Hide();\r\n                    };\r\n                    this.UndoPie = function (e) {\r\n                        let pie = e.currentTarget;\r\n                        pie.setAttribute('stroke-opacity', 0);\r\n                        this.Hide();\r\n                    }\r\n\r\n                },\r\n                AfterBuild: function () {\r\n\r\n                }\r\n            });\r\n            Lure.AddEventListenerGlobal('mouseover', '.mt-chart-point, .mt-chart-tooltipable', function (e) {\r\n                this.Tooltip.Do(e);\r\n            }, this.Content, this);\r\n            Lure.AddEventListenerGlobal('mouseout', '.mt-chart-point, .mt-chart-tooltipable' , function (e) {\r\n                chart.Tooltip.Undo(e);           }, this.Content);\r\n            /*</tooltips>*/\r\n\r\n            this.TestB = function () {\r\n                let per = performance.now();\r\n               // Builder();\r\n                Lure.Perf(per, 'builder');\r\n            };\r\n            /*\r\n            this._TimerRefresh = null;\r\n            this._IntervalResponse = setInterval(function () {\r\n                if (this.Width !== LastRender.Width || this.Height !== LastRender.Height){\r\n                    clearTimeout(this._TimerRefresh);\r\n                    console.log('[changed]');\r\n                    LastRender.Height = this.Height;\r\n                    LastRender.Width = this.Width;\r\n                    this._TimerRefresh = setTimeout(function () {\r\n                        console.log('[redraw]');\r\n                        Refresh.call(this);\r\n\r\n\r\n                    }.bind(this) ,200);\r\n                }\r\n            }.bind(this), 200);\r\n            */\r\n            this.Buffer = Buffer;\r\n\r\n            // Init\r\n\r\n\r\n            this.Width;   //just init\r\n            //this.Heigth;   //just init\r\n            //pp.Perf('Constructor');\r\n            Refresh.call(this);\r\n            //Refresh.call(this);\r\n            //**  API  **//\r\n\r\n            this.Refresh = function () {\r\n                Refresh.call(this);\r\n            }.bind(this);\r\n        }\r\n        get Height(){\r\n            return this.Block.Svg.clientHeight;\r\n        }\r\n        get Width(){\r\n            return this.Block.Svg.clientWidth - this.Options.Padding;\r\n        }\r\n        /*statics*/\r\n        static GetSeriePointOptions(serie, isGraph){\r\n            let p = serie.Point ? serie.Point : {};\r\n            p.Visible = (typeof p.Visible === 'undefined' || p.Visible);\r\n            p.Radius = p.Radius? p.Radius : (4+serie.Width/4);\r\n            if (Number.isNaN(p.Radius))\r\n                debugger;\r\n            return p;\r\n        }\r\n        static GetScaleY(series, height, ctx){\r\n            if (ctx.Type === 'pie'){\r\n                return [];\r\n            }\r\n            let min = series[0].Data[0];\r\n            let max = series[0].Data[0];\r\n            let isAutoScale = true;\r\n            let isAutoStep = true;\r\n            if (ctx.Options.AxisY.Scale[0] !== 'auto' && ctx.Options.AxisY.Scale[1] !== 'auto')\r\n            {\r\n                isAutoScale = false;\r\n                min = ctx.Options.AxisY.Scale[0];\r\n                max = ctx.Options.AxisY.Scale[1];\r\n            }\r\n            if (ctx.Options.AxisY.Scale[2] !== 'auto')\r\n                isAutoStep = false;\r\n            let mm = [ [series[0].Data[0],series[0].Data[0]] ];\r\n            let index = 0;\r\n            let scales = [];\r\n\r\n            let sc = {\r\n                Scales: [],\r\n                Dict: [],\r\n                MinMax: null\r\n            };\r\n            for (let i = 0; i < series.length; i++){\r\n                sc.Dict[i] = 0;\r\n                if (series[i].OwnAxis){\r\n                    index++;\r\n                    if (typeof series[i].OwnAxis[0] !== 'undefined')\r\n                        mm.push(series[i].OwnAxis);\r\n                    else\r\n                        mm.push([series[i].Data[0],series[i].Data[0]]);\r\n                    sc.Dict[i] = index;\r\n                }\r\n                for (let j = 0; j < series[i].Data.length; j++){\r\n                    if (isAutoScale){\r\n                        if (series[i].Data[j] < min)\r\n                            min = series[i].Data[j];\r\n                        if (series[i].Data[j] > max)\r\n                            max = series[i].Data[j];\r\n                    }\r\n                    if (series[i].OwnAxis && typeof series[i].OwnAxis[0] === 'undefined'){\r\n                        if (series[i].Data[j] < mm[index][0])\r\n                            mm[index][0] = series[i].Data[j];\r\n                        if (series[i].Data[j] > mm[index][1])\r\n                            mm[index][1] = series[i].Data[j];\r\n                    }\r\n                }\r\n            }\r\n            mm[0] = [min, max];\r\n            sc.MinMax = mm;\r\n            for (let i = 0; i < mm.length; i++){\r\n                let order = mm[i][1].toString().length;\r\n                let step;\r\n                if (i===0 && !isAutoStep){\r\n                    step = ctx.Options.AxisY.Scale[2];\r\n                }\r\n                else{\r\n                    step = mm[i][2]? mm[i][2] : ( (mm[i][1]-mm[i][0] )*40 /height / (Math.pow(10, order-1))/5 ).toFixed(1) * Math.pow(10, order-1)*5;\r\n                }\r\n                let s = mm[i][0];\r\n                let scale = [];\r\n                if (order < 3 || true){\r\n                    //debugger;\r\n                    while (s <= mm[i][1] + ctx.Options.Series[i].Width/2){\r\n                        scale.push(s);\r\n                        s += step;\r\n                    }\r\n                    scale.push(s);\r\n                    sc.Scales.push(scale);\r\n                }\r\n            }\r\n            return sc;\r\n        }\r\n\r\n        static GetAbscissa(labels, width){\r\n            const stepX = width / (labels.length);\r\n            return labels.map(function(a,i){return i*stepX});\r\n        }\r\n        static GetOrdinata(serie, scale, mm, height){\r\n            let min = mm[0];\r\n            let max = mm[1];\r\n            const scaleCoefficient = scale[scale.length-1] / max;\r\n            let ordinata = [];\r\n            for (let j= 0; j < serie.length; j++){\r\n                ordinata.push( height - (  (serie[j] - min) * height/(max-min)/scaleCoefficient )  );\r\n            }\r\n            //console.log('Y', Y);\r\n            //console.log('ordinate', ordinate);\r\n            //console.log(`min=${min} max=${max}`, height);\r\n            //ordinata.push(ordinate);\r\n            //console.log('ordinata', ordinata);\r\n            return ordinata;\r\n\r\n\r\n\r\n        }\r\n        static GetPoints(X,Y, padding = 0){\r\n            let points = [];\r\n            //let length = X.length >= Y.length ? X.length:Y.length;\r\n            for (let i = 0; i < Y.length; i++){\r\n                points.push([X[i] + padding, Y[i]]);\r\n            }\r\n            return points;\r\n        }\r\n        static aGetPath(points, type, line, color, width){\r\n            switch (type){\r\n                case 'line':\r\n                    return Lure.Chart.GetPathLine(points, line, color, width);\r\n                case 'bar':\r\n                    return Lure.Chart.GetPathBar(points, line, color, width);\r\n                case 'pie':\r\n                    return '';\r\n            }\r\n        }\r\n        static aGetPathLine(points, line, color, width, isDots=true){\r\n            const n = points.length;\r\n\r\n            let xs = [];        //x\r\n            let ys = [];        //y\r\n            let dys = [];       //dx\r\n            let dxs = [];       //dy\r\n            let ds = [];        //derivative\r\n            let ms = [];        //desired slope (m) at each point using Fritsch-Carlson method\r\n            for(let i = 0; i < n; i++) {\r\n                xs[i] = points[i][0];\r\n                ys[i] = points[i][1];\r\n            }\r\n            // Calculate deltas and derivative\r\n            for(let i = 0; i < n - 1; i++) {\r\n                dys[i] = ys[i + 1] - ys[i];\r\n                dxs[i] = xs[i + 1] - xs[i];\r\n                ds[i] = dys[i] / dxs[i];\r\n            }\r\n            // Determine desired slope (m) at each point using Fritsch-Carlson method\r\n            // See: http://math.stackexchange.com/questions/45218/implementation-of-monotone-cubic-interpolation\r\n            ms[0] = ds[0];\r\n            ms[n - 1] = ds[n - 2];\r\n            for(let i = 1; i < n - 1; i++) {\r\n                if(ds[i] === 0 || ds[i - 1] === 0 || (ds[i - 1] > 0) !== (ds[i] > 0)) {\r\n                    ms[i] = 0;\r\n                } else {\r\n                    ms[i] = 3 * (dxs[i - 1] + dxs[i]) / (\r\n                        (2 * dxs[i] + dxs[i - 1]) / ds[i - 1] +\r\n                        (dxs[i] + 2 * dxs[i - 1]) / ds[i]);\r\n                    if(!isFinite(ms[i])) {\r\n                        ms[i] = 0;\r\n                    }\r\n                }\r\n            }\r\n            let d = `M ${xs[0]},${ys[0]}`;\r\n            let dots = '<g class=\"mt-chart-dots\">';\r\n            for(let i = 0; i < n - 1; i++) {\r\n                //console.log(d);\r\n                d += ` C ${xs[i] + dxs[i] / 3},${ys[i] + ms[i] * dxs[i] / 3} ${xs[i + 1] - dxs[i] / 3},${ys[i + 1] - ms[i + 1] * dxs[i] / 3} ${xs[i + 1]},${ys[i + 1]}`;\r\n                if (isDots)\r\n                    dots += Lure.Chart.GetPathLineDot(xs[i] , ys[i], line, i, color, width );\r\n            }\r\n            dots += '</g>';\r\n            //return d;\r\n            //console.log(d);\r\n            return `<g class=\"mt-chart-serie\"><path data-line=\"${line}\" d=\"${d}\" fill=\"none\" stroke=\"${color}\" stroke-width=\"${width}\"></path> ${dots}</g>`;\r\n        }\r\n        static GetPathLineDot(x,y, i,j, color, width){\r\n            return `<circle class=\"mt-chart-point\" data-type=\"line\" data-line=\"${i}\" data-item=\"${j}\" cx=\"${x}\" cy=\"${y}\" r=\"${width}\" stroke=\"${color}\" stroke-width=\"2\" fill=\"#fff\" ></circle>`\r\n\r\n        }\r\n        static aGetPathBar(points, line, color, width){\r\n            const wd = 30;\r\n            console.log('GetPathBar', points);\r\n            // return '';\r\n            let p = `<path data-line=\"${line}\" d=${0} fill=\"${color}\" stroke=\"${color}\" stroke-width=\"${width}\"></path>`;\r\n            // let d = `M ${points[0][0]}  ${points[0][1]}`;\r\n            let dots = '';\r\n            for (let i = 0; i < points.length; i++){\r\n                let d =`M ${points[i][0]} ${points[i][1]} L ${points[i][0]} ${points[i][1]}`;\r\n                //dots += Lure.Chart.GetPatwehLineDot(points[i][0] , points[i][1], line, i, color, width );\r\n            }\r\n            // debugger;\r\n            return do2ts;\r\n        }\r\n\r\n\r\n\r\n        static PolarToCartesius(centerX, centerY, radius, angleInDegrees) {\r\n            let angleInRadians = (angleInDegrees-0) * Math.PI / 180;\r\n\r\n            return {\r\n                x: centerX + (radius * Math.cos(angleInRadians)),\r\n                y: centerY + (radius * Math.sin(angleInRadians))\r\n            };\r\n        }\r\n        static PieArc(x, y, radius, startAngle, endAngle){\r\n            //debugger;\r\n            let start = Lure.Chart.PolarToCartesius(x, y, radius, endAngle);\r\n            let end = Lure.Chart.PolarToCartesius(x, y, radius, startAngle);\r\n\r\n            let largeArcFlag = endAngle - startAngle <= 180 ? \"0\" : \"1\";\r\n\r\n            let d = [\r\n                \"M\", start.x, start.y,\r\n                \"A\", radius, radius, 0, largeArcFlag, 0, end.x, end.y\r\n            ].join(\" \");\r\n\r\n            return d;\r\n        }\r\n        static CheckOwnAxis(ep){\r\n            if (!ep.OwnAxis)\r\n                return false;\r\n            if (Array.isArray(ep.OwnAxis)){\r\n                let min = false;\r\n                let max = false;\r\n                if (ep.OwnAxis[0] !== 'auto' || typeof ep.OwnAxis[0] !== 'undefined')\r\n                    min = ep.Data[0];\r\n                if (ep.OwnAxis[1] !== 'auto' || typeof ep.OwnAxis[1] !== 'undefined')\r\n                    max = ep.Data[1];\r\n                if (!min && !max)\r\n                    return ep.OwnAxis;\r\n\r\n                for (let i =0; i< ep.Data.length; i++){\r\n                    if (ep.Data[i] < min)\r\n                        min = ep.Data[i];\r\n                    if (ep.Data[i] > max)\r\n                        max = ep.Data[i];\r\n                }\r\n            }\r\n        }\r\n        /*builder*/\r\n        static MakeLegend(Serie, i){\r\n            let id = `lc-legeng_ch${Lure.Chart.Count}`;\r\n            return `<div class=\"mt-chart-legend__item row\">\r\n                          <input class=\"mt-legend-checkbox\" type=\"checkbox\" ${Serie.isVisible? 'checked=\"cheched\"':''} id=\"${id}\">\r\n                          <div class=\"mt-legend-icon\" style=\"background-color: ${Serie.Color}\"></div>\r\n                          <label class=\"mt-legend-label\" for=\"${id}\">${Serie.Name}</label>\r\n                        </div>`;\r\n        }\r\n        static GetGrid(sizeX, sizeY, padding=0){\r\n            let grid = ``;\r\n            for (let i = 0; i < sizeY; i++){\r\n                grid += `<div class=\"mt-chart__grid-line row flex-100 flex-between\" >`;\r\n                for (let j = 0; j < sizeX; j++) {\r\n                    if (j === 0)\r\n                        grid += `<div class='mt-chart__grid-item flex-100' style=\"width: ${padding}px; max-width: ${padding}px\"></div>`;\r\n                    grid += `<div class='mt-chart__grid-item flex-100'></div>`;\r\n                }\r\n                grid += `</div>`;\r\n            }\r\n            grid += ``;\r\n            return grid;\r\n        }\r\n    }\r\n};\r\n\r\nLure.Chart = Lure.Plugin.Chart.Chart;\r\nLure.Chart.Count = 0;\r\n\r\n\r\nLure._GenerateString = function (prefix='') {\r\n    let gen = prefix+(Math.random().toString(36)+Math.random().toString(36)+Math.random().toString(36)).replace(\"0.\", '').replace(/[\\d]+/, '').substring(0,1);\r\n    if (Lure.Select(`#${gen}`)){\r\n        gen = Lure._GenerateString(prefix);\r\n    }\r\n    return gen;\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"]}